package views

import (
	"believer/movies/components/auth"
	"believer/movies/components/button"
	"believer/movies/components/dropdown"
	"believer/movies/components/empty-state"
	"believer/movies/components/icon"
	"believer/movies/components/layout"
	"believer/movies/components/link"
	"believer/movies/components/list"
	"believer/movies/components/section"
	"believer/movies/components/separator"
	"believer/movies/types"
	"fmt"
)

type WatchlistProps struct {
	Movies                   types.Movies
	UnreleasedMovies         types.Movies
	MoviesWithoutReleaseDate types.Movies
}

templ SortWatchlist(route string, currentOrder string) {
	@dropdown.Dropdown(dropdown.Props{
		Name:    "sortOrder",
		Route:   route,
		Options: []string{"Date added", "Release date"},
		Value:   currentOrder,
	})
}

type ReleaseDate string

const (
	Released   ReleaseDate = "released"
	Unreleased ReleaseDate = "unreleased"
	NoDate     ReleaseDate = "nodate"
)

type WatchlistListProps struct {
	Action      templ.Component
	Movies      types.Movies
	Order       string
	ReleaseDate ReleaseDate
	Title       string
}

templ WatchlistList(p WatchlistListProps) {
	@section.Section(section.Props{
		Action:        p.Action,
		NumberOfItems: len(p.Movies),
		Title:         p.Title,
	}) {
		@list.Ol() {
			for _, movie := range p.Movies {
				@list.Li() {
					@link.Link(link.Props{Href: movie.LinkTo()}) {
						{ movie.Title }
					}
					@separator.Separator()
					<div class="trailing">
						if p.Order != "" {
							if p.Order == "Date added" {
								@link.Link(link.Props{Href: movie.LinkToCreatedYear()}) {
									{ movie.ISOCreatedDate() }
								}
							} else if p.Order == "Release date" {
								@link.Link(link.Props{Href: movie.LinkToCreatedYear()}) {
									{ movie.ISOReleaseDate() }
								}
							}
						}
						@auth.IsAuthenticated() {
							if p.ReleaseDate == Released {
								@link.Link(link.Props{
									AriaLabel: "Add watch",
									Class:     "link--no-border",
									Href:      movie.LinkToWatchlistAdd(),
								}) {
									@icon.Icon(icon.Props{Name: icon.Eye})
								}
							}
							@button.Button(button.Props{
								Rank: button.Secondary,
								Type: button.TypeButton,
								Attrs: templ.Attributes{
									"hx-target":  "closest li",
									"hx-swap":    "outerHTML",
									"hx-delete":  fmt.Sprintf("/watchlist/%d", movie.ID),
									"hx-confirm": fmt.Sprintf("Delete %s from watchlist?", movie.Title),
								},
							}) {
								Delete
							}
						}
					</div>
				}
			}
		}
	}
}

templ Watchlist(props WatchlistProps) {
	@layout.Layout(layout.Props{Title: "Watchlist"}) {
		if len(props.Movies) > 0 {
			@WatchlistList(WatchlistListProps{
				Movies:      props.Movies,
				Title:       "Movies",
				Action:      SortWatchlist("/watchlist/movies", "Date added"),
				Order:       "Date added",
				ReleaseDate: Released,
			})
		} else {
			@emptystate.EmptyState() {
				Watchlist empty
			}
		}
		if len(props.UnreleasedMovies) > 0 {
			@WatchlistList(WatchlistListProps{
				Movies: props.UnreleasedMovies,
				Title:  "Unreleased movies",
				Action: SortWatchlist("/watchlist/unreleased-movies", "Release date"),
				Order:  "Release date",
			})
		}
		if len(props.MoviesWithoutReleaseDate) > 0 {
			@WatchlistList(WatchlistListProps{
				Movies: props.MoviesWithoutReleaseDate,
				Title:  "No release date",
			})
		}
	}
}
