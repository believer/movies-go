// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getMovie = `-- name: GetMovie :one
SELECT
    m.id,
    m.title,
    m.release_date,
    m.runtime,
    m.imdb_id,
    m.overview,
    m.original_title,
    m.tagline,
    se.name AS "series",
    se.id AS "series_id",
    ms.number_in_series,
    r.rating,
    COALESCE(ARRAY_TO_JSON(ARRAY (
                SELECT
                    jsonb_build_object('id', id, 'name', name)
                FROM ( SELECT DISTINCT ON (pc.id)
                    pc.id, pc.name FROM production_company pc
                    JOIN movie_company mc2 ON mc2.company_id = pc.id
                    WHERE
                        mc2.movie_id = m.id ORDER BY pc.id, pc.name) AS uniq_pc ORDER BY name ASC)), '[]') AS production_companies,
    COALESCE(ARRAY_TO_JSON(ARRAY (
                SELECT
                    jsonb_build_object('id', id, 'name', name)
                FROM ( SELECT DISTINCT ON (pc.id)
                        pc.id, pc.name
                    FROM production_country pc
                    JOIN movie_country mc2 ON mc2.country_id = pc.id
                    WHERE
                        mc2.movie_id = m.id ORDER BY pc.id, pc.name) AS uniq_pc ORDER BY name ASC)), '[]') AS production_countries,
    r.created_at at time zone 'UTC' at time zone 'Europe/Stockholm' AS "rated_at",
    COALESCE(ARRAY_TO_JSON(ARRAY_AGG(DISTINCT jsonb_build_object('name', g.name, 'id', g.id)) FILTER (WHERE g.name IS NOT NULL)), '[]') AS genres,
    COALESCE(ARRAY_TO_JSON(ARRAY_AGG(DISTINCT jsonb_build_object('name', l.english_name, 'id', l.id)) FILTER (WHERE l.english_name IS NOT NULL)), '[]') AS languages
FROM
    movie AS m
    LEFT JOIN movie_genre AS mg ON mg.movie_id = m.id
    LEFT JOIN genre AS g ON g.id = mg.genre_id
    LEFT JOIN rating AS r ON r.movie_id = m.id
        AND r.user_id = $2
    LEFT JOIN movie_series AS ms ON ms.movie_id = m.id
    LEFT JOIN series AS se ON se.id = ms.series_id
    LEFT JOIN movie_language AS ml ON ml.movie_id = m.id
    LEFT JOIN "language" AS l ON l.id = ml.language_id
WHERE
    m.id = $1
GROUP BY
    1,
    r.id,
    se.id,
    ms.number_in_series
`

type GetMovieParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

type GetMovieRow struct {
	ID                  int32       `json:"id"`
	Title               string      `json:"title"`
	ReleaseDate         pgtype.Date `json:"release_date"`
	Runtime             int16       `json:"runtime"`
	ImdbID              string      `json:"imdb_id"`
	Overview            pgtype.Text `json:"overview"`
	OriginalTitle       pgtype.Text `json:"original_title"`
	Tagline             pgtype.Text `json:"tagline"`
	Series              pgtype.Text `json:"series"`
	SeriesID            pgtype.Int4 `json:"series_id"`
	NumberInSeries      pgtype.Int4 `json:"number_in_series"`
	Rating              pgtype.Int2 `json:"rating"`
	ProductionCompanies interface{} `json:"production_companies"`
	ProductionCountries interface{} `json:"production_countries"`
	RatedAt             interface{} `json:"rated_at"`
	Genres              interface{} `json:"genres"`
	Languages           interface{} `json:"languages"`
}

func (q *Queries) GetMovie(ctx context.Context, arg GetMovieParams) (GetMovieRow, error) {
	row := q.db.QueryRow(ctx, getMovie, arg.ID, arg.UserID)
	var i GetMovieRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.ReleaseDate,
		&i.Runtime,
		&i.ImdbID,
		&i.Overview,
		&i.OriginalTitle,
		&i.Tagline,
		&i.Series,
		&i.SeriesID,
		&i.NumberInSeries,
		&i.Rating,
		&i.ProductionCompanies,
		&i.ProductionCountries,
		&i.RatedAt,
		&i.Genres,
		&i.Languages,
	)
	return i, err
}
